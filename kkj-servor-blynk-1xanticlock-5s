#define BLYNK_TEMPLATE_NAME "xxxxx"
#define BLYNK_AUTH_TOKEN "xxxxxx"
#define BLYNK_TEMPLATE_ID "xxxxxx"

// Pastikan definisi untuk Blynk IoT
#define BLYNK_FIRMWARE_VERSION "0.1.0"
#define BLYNK_PRINT Serial
#include <WiFi.h>
#include <WiFiManager.h>  // Untuk setup WiFi
#include <BlynkSimpleEsp32.h>  // Untuk sambungan ke Blynk IoT
#include <ESP32Servo.h>  // Untuk kawal servo pada ESP32
#include <NTPClient.h>  // Untuk sync waktu real-time
#include <WiFiUdp.h>  // Untuk NTP

// Pin servo (signal pin) - sambung ke GPIO 13
#define SERVO_PIN 13

// Objek servo
Servo myServo;

// Objek NTP (UTC+8 untuk Malaysia, update setiap 60 saat)
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 28800, 60000);

// Masa feeding (format 24 jam)
const int pagiHour = 7;
const int pagiMinute = 0;
const int tengahariHour = 12;
const int tengahariMinute = 0;
const int petangHour = 19;  // 7 petang = 19:00
const int petangMinute = 0;

// Flag untuk elak feeding berulang
bool fedPagi = false;
bool fedTengahari = false;
bool fedPetang = false;

// Flag untuk jejak status manual feeding dan suis V0
volatile bool manualFeeding = false;
volatile bool switchV0State = false;

// Fungsi untuk putar servo 1 kali (1 counterclockwise)
bool putarServo(String session) {
  Serial.println("Memulakan putaran servo untuk " + session + "...");
  bool completed = true;  // Jejaki jika feeding selesai penuh

  // 1 putaran counterclockwise
  myServo.write(120);  // Kelajuan sederhana counterclockwise untuk ~12 RPM
  unsigned long startTime = millis();
  while (millis() - startTime < 5000) {  // 5 saat per putaran
    if (session == "manual" && !switchV0State) {  // Check status V0
      myServo.write(90);  // Stop segera
      Serial.println("Manual feeding dihentikan oleh suis OFF!");
      completed = false;
      manualFeeding = false;
      return completed;
    }
    Blynk.run();  // Pastikan Blynk kekal aktif
    delay(10);  // Delay kecil untuk elak CPU hog
  }

  myServo.write(90);  // Stop servo
  Serial.println("Servo telah diputar 1 kali (1 counterclockwise)!");

  // Hantar notifikasi berdasarkan sesi
  if (session == "pagi") {
    Blynk.logEvent("pagi_feeding", "Pagi feeding selesai");
  } else if (session == "tengahari") {
    Blynk.logEvent("tengahari_feeding", "Tengahari feeding selesai");
  } else if (session == "petang") {
    Blynk.logEvent("petang_feeding", "Petang feeding selesai");
  } else if (session == "manual") {
    Blynk.logEvent("feeding_complete", "Manual feeding selesai");
  }

  if (session == "manual") {
    manualFeeding = false;  // Reset flag manual
  }
  return completed;
}

// Blynk handler untuk manual switch (V0)
BLYNK_WRITE(V0) {
  int switchValue = param.asInt();  // Ambil nilai switch (1=ON, 0=OFF)
  switchV0State = switchValue;  // Simpan status V0
  Serial.print("Switch V0 dikesan: ");
  Serial.println(switchValue);
  if (switchValue == 1) {
    Serial.println("Manual feeding dipicu!");
    manualFeeding = true;  // Set flag manual
    putarServo("manual");  // Putar 1 kali (counterclockwise) dan hantar notifikasi manual
    Blynk.virtualWrite(V0, 0);  // Reset switch ke OFF
    switchV0State = false;  // Reset status V0
  } else if (manualFeeding) {
    Serial.println("Switch V0 OFF, menghentikan manual feeding...");
    // Servo akan dihentikan dalam putarServo()
  }
}

void setup() {
  // Start Serial untuk debug
  Serial.begin(115200);
  Serial.println("Memulakan Smart Fish Feeder...");

  // Setup WiFi Manager
  WiFiManager wifiManager;
  wifiManager.autoConnect("SmartFishFeeder_AP");  // Nama AP jika tak connect WiFi
  Serial.println("WiFi tersambung!");

  // Sambung ke Blynk IoT
  Blynk.begin(BLYNK_AUTH_TOKEN, WiFi.SSID().c_str(), WiFi.psk().c_str());
  Serial.println("Menyambung ke Blynk...");

  // Setup servo
  myServo.attach(SERVO_PIN);
  myServo.write(90);  // Stop servo pada permulaan
  Serial.println("Servo diinisialisasi.");

  // Start NTP client
  timeClient.begin();
  timeClient.update();
  Serial.println("NTP client dimulakan.");
}

void loop() {
  Blynk.run();  // Jalankan Blynk

  // Update waktu NTP
  timeClient.update();

  // Dapat waktu semasa
  int currentHour = timeClient.getHours();
  int currentMinute = timeClient.getMinutes();

  // Print waktu untuk debug
  static unsigned long lastPrint = 0;
  if (millis() - lastPrint >= 60000) {  // Print setiap 1 minit
    Serial.print("Waktu semasa: ");
    Serial.print(currentHour);
    Serial.print(":");
    Serial.println(currentMinute);
    lastPrint = millis();
  }

  // Check untuk feeding auto, hanya jika tiada manual feeding
  if (!manualFeeding) {
    if (currentHour == pagiHour && currentMinute == pagiMinute && !fedPagi) {
      Serial.println("Auto feeding pagi dipicu!");
      putarServo("pagi");  // Putar 1 kali (counterclockwise) dan hantar notifikasi pagi
      fedPagi = true;
    } else if (currentHour == tengahariHour && currentMinute == tengahariMinute && !fedTengahari) {
      Serial.println("Auto feeding tengahari dipicu!");
      putarServo("tengahari");  // Putar 1 kali (counterclockwise) dan hantar notifikasi tengahari
      fedTengahari = true;
    } else if (currentHour == petangHour && currentMinute == petangMinute && !fedPetang) {
      Serial.println("Auto feeding petang dipicu!");
      putarServo("petang");  // Putar 1 kali (counterclockwise) dan hantar notifikasi petang
      fedPetang = true;
    }
  }

  // Reset flag pada minit seterusnya
  if (currentMinute != pagiMinute) fedPagi = false;
  if (currentMinute != tengahariMinute) fedTengahari = false;
  if (currentMinute != petangMinute) fedPetang = false;

  delay(10);  // Delay kecil untuk elak CPU hog
}
